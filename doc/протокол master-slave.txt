///////////////////////////////////////////////////////////////////////////////////////////////////////////
1. Общая информация по Modbus.
Мастер обменивается данными со слейвами через протокол Modbus RTU (см. \doс\Modbus — Википедия.htm).

С точки зрения мастера - все параметры слейва хранятся у слейва в 2х-байтных регистрах хранения (Holding Registers).
Регистры хранения можно читать с помощью функции чтения (0x03), и писать с помощью функции записи (0x06). Другие стандартные функции\типы данных Modbus (они перечислены в википедии), я не поддерживаю.

///////////////
1.1 чтение регистра хранения:
Стандартный запрос чтения регистра от мастера к слейву выглядит так:
[адрес слейва 1байт] [номер функции 1 байт] [номер регистра 2 байта] [количество регистров, которое надо считать 2 байта]  [crc 2 байта]
Слейв шлёт в овет:
[адрес слейва 1байт] [номер функции 1 байт] [количество байт в ответе 1 байта] [ответ N байт]  [crc 2 байта]

к примеру, чтобы считать у слейва с адресом 0x01, 5 регистров начиная с адреса 0x30 мастер высылает:
[01] [03] [00 30] [00 05] [85 C6]
слейв обратно возвращает (регистр 0x30=0x004D 0x31=0x0000 0x32=0x000 00x33=0x0000  0x34=0x0000):
[01] [03] [0A] [004D 0000 0000 0000 0000] [4D E5]

///////////////
1.2 запись в регистр хранения:
Стандартный запрос записи регистра от мастера к слейву выглядит так:
[адрес слейва 1байт] [номер функции 1 байт] [номер регистра 2 байта] [новое значение для регистра 2 байта] [crc 2 байта]
Слейв шлёт в ответ, копию запроса обратно.

к примеру, чтобы записать в слейва с адресом 0x01, в регистр 0x0007 значение 0x000F, мастер высылает:
[01] [06] [00 07] [00 0F] [78 0F]
слейв обратно возвращает, копию запроса:
[01] [06] [00 07] [00 0F] [78 0F]

///////////////
1.3 широковещательные запросы
Если мастер хочет обратиться сразу ко всем слейвам, он шлет широковещательный запрос (адрес слейва равен 0x00 в этом случае). Слейвы обрабатывают запрос, и ничего не возвращают в ответ.
К примеру, чтобы записать в регистр 0x01 значение 0x01 на всех слейвах, мастер шлет:
[00] [06] [00 01] [00 01] [18 1B]



///////////////////////////////////////////////////////////////////////////////////////////////////////////
2.Реализация Modbus в нашем проекте.

/////////////////////////////////////////
2.1 Регистры хранения
Регистры хранения я условно поделил на 4 типа (см. ниже Карту памяти регистров).

///////////////
2.1.1 Регистры, хранящие текущие значения датчиков (0x30-0x39), или записанные значения датчиков (100 значений для каждого датчика, регистры 0x64-0x3E7).
Эти регистры можно читать с помощью функции (0x03), писать в них не следует.
Если происходит чтение текущих значения датчиков (0x30-0x39), слейв в реальном времени делает АЦП, и возвращает ответ мастеру.
Если происходит чтение записанных значений (0x64-0x3E7), то данные читаются из оперативной памяти.

///////////////
2.1.2 Конфигурационные регистры (0x03-0x0F). 
REG_CONFIG_SLAVE_ADDR           0x03 //адрес слейва
REG_CONFIG_START_PAUSE          0x04 //пауза перед стартом измерений в мсек
REG_CONFIG_MEASURE_INTERVAL     0x05 //интервал между измерениями, т.е меряем 100 точек между каждой точкой выдерживаем данный интервал времени
REG_CONFIG_K1                   0x06 //калибровочный коэффициент для 1го датчика
REG_CONFIG_K2                   0x07
REG_CONFIG_K3                   0x08
REG_CONFIG_K4                   0x09
REG_CONFIG_K5                   0x0A
REG_CONFIG_K6                   0x0B
REG_CONFIG_K7                   0x0C
REG_CONFIG_K8                   0x0D
REG_CONFIG_K9                   0x0E
REG_CONFIG_K10                  0x0F //калибровочный коэффициент для 10го датчика
В них хранятся параметры слейва. Через функцию 0x03 эти регистры можно читать.
Важно понимать следующее: при записи в эти регистры меняются только сами регистры, переменные соответствующие им в оперативной памяти слейва, не меняются. Для того чтобы изменить переменные и сохранить их в EEPROM микроконтроллера, требуется дополнительно записать определенное значение в управляющий регистр REG_CONTROL_SAVE (см. ниже).

///////////////
2.1.3 Управляющие регистры.
REG_CONTROL_MEASURE_START       0x01 //при записи в этот регистр 1 начинаются измерения, по всем слейвам
REG_CONTROL_SAVE                0x02 //при записи в этот регистр 1-4, сохраняются соответствующие параметры в EEPROM
При записи в такой регистр правильного значения, слейв производит определенное действие.

2.1.3.1 Регистр 0x01 (REG_CONTROL_MEASURE_START), при записи в него значения 0x01 на всех слейвах начинается измерение 100 точек.
Т.е чтобы начать измерение одновременно, но всех слейвах, мастер шлет широковещательный запрос, в котором записывает значение 0x01 в регистр с адресом 0x01:
[00] [06] [00 01] [00 01] [18 1B]

2.1.3.2 Регистр 0x02 (REG_CONTROL_SAVE)
- при записи 0x01 в этот регистр: значения калибровочных коэффициентов в оперативной памяти слейва подменяются соответствующими значениями из REG_CONFIG_K1 .. REG_CONFIG_K10, новые значения сохраняются в EEPROM, т.е при перезагрузке слейва не будут утеряны.
- при записи 0x02 в этот регистр: адрес слейва становиться равным REG_CONFIG_SLAVE_ADDR, и новое значение сохраняется в EEPROM.
- при записи 0x03 в этот регистр: меняется в оперативной памяти и сохраняется в EEPROM параметр REG_CONFIG_START_PAUSE.
- при записи 0x04 в этот регистр: меняется в оперативной памяти и сохраняется в EEPROM параметр REG_CONFIG_MEASURE_INTERVAL.

Еще важный нюанс: для того чтобы выставить какой-нибудь параметр на всех слейвах одновременно:
 - мастер отправляет широковещательный запрос с записью соответствующего конфигурационного регистра
-  затем мастер отправляет широковещательный запрос с записью в управляющий регистр, чтобы сохранить изменение в EEPROM и оперативной памяти.
При этом слейвы ничего не шлют в ответ и есть риск что до одного из них запрос не дошел, т.е мы думаем что все слейвы поменяли значение, а реально не все.

///////////////
2.1.4 Отладочные регистры.
В них всякая отладочная информация, вытаскивать их наружу не надо.



/////////////////////////////////////////
2.2 Особенности конфигурирования слейва

///////////////
2.2.1 Изменение конфигурационных регистров
При записи конфигурационных регистров слейва, мастер должен сам контролировать допустимые диапазоны записываемых значений.
REG_CONFIG_SLAVE_ADDR:        1..72
REG_CONFIG_START_PAUSE:       1..100
REG_CONFIG_MEASURE_INTERVAL:  1..100
REG_CONFIG_Kx:                12000..16000
Запись неправильного значения в слейв может привезти к непредсказуемым результатам.

///////////////
2.2.2 Калибровочный коэффициент для вычисления давления
Алгоритм вычисления калибровочного коэффициента:
слейв выполняет АЦП - на выходе значение 0..4095, 
ему соответствует давление, мАтм 0..K
К - это максимальное давление, соответствующее значению 4095 с АЦП.
К можно выставлять от 12000..16000 для каждого датчика индивидуально
Тогда текущее значение давления в мАтм = текАЦП(2байта)*К(2байта)/4095

Слейв делает следующее вычисление на свой стороне:
REG_SENSOR1_CURRENT_VALUE = REG_CONFIG_K1 * текущееАЦП/4095
Полученное значение считывается мастером из регистра REG_SENSOR1_CURRENT_VALUE.
Дальше мастер делит значение на 1000 (чтобы получить не мАтм, а Атм) и выводит на экран.


/////////////////////////////////////////
2.3 Управление таймаутами на линии + управлением приёмо-передатчиком RS485
Мастер общается со слейвами на скорости 115200 бит/сек (8n1 т.е без бита четности 8 бит данных и 1 стоповый бит)
Общая идея такова: тот кто отправляет данные ждет 400мкс перед отправкой, тот кто принимает данные, в случае любой ошибки ждет 300мкс.
Интервалы отличаются, чтобы исключить гонку во время ожидания между устройствами. 

///////////////
2.3.1 Алгоритм работы слейва
Слейв в бесконечном цикле читает USART-линию.
- Если пришел байт, и это адрес слейва или широковещательный адрес, 
   - то слейв принимает оставшиеся байты, ожидая каждый байт в бесконечном цикле. 
      - проверяет crc, если не совпало, то слейв ничего не высылает в ответ мастеру, и ждет паузы на линии длинной 300мкс, обнаружив такую паузу, слейв снова ожидает начала пакета (байта с адресом слейва).
      - если crc совпало, то слейв:
        - выставляет ножку приемо-передатчика в 1 (TX-режим)
        - ждет 400мкс (по стандарту Modbus RTU надо ждать минимум 3.5 символа между пакетами + за это время затухают помехи на линии после включения приемо-передатчика)  
        - отправляет ответ мастеру.
        - выставляет ножку приемо-передатчика в 0 (RX-режим) 
        - После этого ждет паузы в линии длиной 300мкс, обнаружив такую паузу, слейв снова ожидает начала пакета.
- Если это не адрес слейва, то слейв ждет паузы на линии длинной 300мкс, обнаружив такую паузу, слейв снова ожидает начала пакета.

///////////////
2.3.2 Алгоритм работы мастера
- мастер выставляет ножку приемо-передатчика в 1 (TX-режим)
- ждет 400мкс (по стандарту Modbus RTU надо ждать минимум 3.5 символа между пакетами + за это время затухают помехи на линии после включения приемо-передатчика)  
- отправляет запрос слейву.
- выставляет ножку приемо-передатчика в 0 (RX-режим) 
- если ответ не пришел в течении 3.2мс, то мастер считает что слейв выключен или пакет до него не дошел, и отправляет пакет заново, либо отправляет пакет другому слейву. Теоретически мастер должен ждать любой интервал времени, больший 300мкс. Я взял 3.2 мс т.к эмулятор слейва под Windows не мгновенно возвращает ответ мастеру, и для него такой таймаут удобен. 
- если ответ пришел в течении 3.2мс. Мастер обрабатывает ответ, проверяет crc, 
  - если crc не совпало, то принятый пакет отбрасывается целиком. Мастер отправляет следующий запрос.
  - если crc совпало, мастер обрабатывает ответ, и  отправляет следующий запрос.

По стандарту modbus: слейв мог бы возвращать код ошибок, выставив в ответе мастеру старший бит номера функции + следом за ним байт с кодом ошибки, я для простоты такую схему возврата ошибок не поддерживаю.



///////////////////////////////////////////////////////////////////////////////////////////////////////////
3. Карта памяти регистров в слейве:

//Управляющие регистры
REG_CONTROL_MEASURE_START       0x01 //при записи в этот регистр 1цы начинаются измерения, по всем слейвам
REG_CONTROL_SAVE                0x02 //при записи в этот регистр 1-4, сохраняются соответствующие параметры в EEPROM

//Конфигурационные регистры
REG_CONFIG_SLAVE_ADDR           0x03 //здесь адрес слейва
REG_CONFIG_START_PAUSE          0x04 //пауза перед стартом измерений в мсек
REG_CONFIG_MEASURE_INTERVAL     0x05 //интервал между измерениями, т.е меряем 100 точек между каждой точкой выдерживаем данный интервал времени
REG_CONFIG_K1                   0x06 //калибровочный коэффициент для 1го датчика
REG_CONFIG_K2                   0x07
REG_CONFIG_K3                   0x08
REG_CONFIG_K4                   0x09
REG_CONFIG_K5                   0x0A
REG_CONFIG_K6                   0x0B
REG_CONFIG_K7                   0x0C
REG_CONFIG_K8                   0x0D
REG_CONFIG_K9                   0x0E
REG_CONFIG_K10                  0x0F //калибровочный коэффициент для 10го датчика

//Регистры с текущими значениями с датчиков
REG_SENSOR1_CURRENT_VALUE       0x30
REG_SENSOR2_CURRENT_VALUE       0x31
REG_SENSOR3_CURRENT_VALUE       0x32
REG_SENSOR4_CURRENT_VALUE       0x33
REG_SENSOR5_CURRENT_VALUE       0x34
REG_SENSOR6_CURRENT_VALUE       0x35
REG_SENSOR7_CURRENT_VALUE       0x36
REG_SENSOR8_CURRENT_VALUE       0x37
REG_SENSOR9_CURRENT_VALUE       0x38
REG_SENSOR10_CURRENT_VALUE      0x39
//Регистры с записанными значениями (100 точек) с каждого датчика
REG_SENSOR1_RECORD_VALUE        0x0064  //здесь 100 сохраненных точек для 1го сенсора
REG_SENSOR2_RECORD_VALUE        0x00C8  //здесь 100 сохраненных точек для 2го сенсора
REG_SENSOR3_RECORD_VALUE        0x012С
REG_SENSOR4_RECORD_VALUE        0x0190
REG_SENSOR5_RECORD_VALUE        0x01F4
REG_SENSOR6_RECORD_VALUE        0x0258
REG_SENSOR7_RECORD_VALUE        0x02BC 
REG_SENSOR8_RECORD_VALUE        0x0320
REG_SENSOR9_RECORD_VALUE        0x0384

//Отладочные регистры:
#define REG_MAGIC               0x00 //тут всегда 0x1234
//статистика Modbus
REG_STAT_TOTAL_FRAME_NUM        0x10
REG_STAT_SLAVE_ADDR_MISMATCH    0x11
REG_STAT_SLAVE_FUNC_MISMATCH    0x12
REG_STAT_CRC_ERROR              0x13
REG_STAT_CRC_OK                 0x14
REG_STAT_FULL_DUMP_NUM          0x15   //каждый раз когда запускаю запись измеренных значений, счетчик увеличивается
//статистика USART
REG_ERROR_USART_FRAME           0x20
REG_ERROR_USART_PARITY          0x21
REG_ERROR_USART_OVERRUN         0x22



///////////////////////////////////////////////////////////////////////////////////////////////////////////
4. Софт под Windows с помощью которого удобно отлаживаться.

///////////////
4.1 Программа под Windows эмулирующая слейв, для платы мастера, подключенной к компьютеру.
\distr\slave\PeakHMISlaveSimulatorInstall.exe
4.1.1 При запуске программы нажимаем OK в окошке About.
4.1.2 Дальше в меню File\Settings надо выставить параметры:
-Delay time 0 //пауза которую слейв выдерживает, прежде чем ответить мастеру.
-Our slave ID 1 //номер эмулируемого слейва
-Com port //выбрать правильный номер COM-порта
-Baude rate 115200
-parity None
-data bits 8
-stop bits 1
-RTS disable
4.1.3 Дальше открываем окна 
Windows\Communication monitor
Windows\Register data
4.1.4
В окне Data monitor надо перейти на вкладку Holding Registers.
В ней можно менять значения регистров, и видеть результаты на плате мастера.

///////////////
4.2 Программы под Windows эмулирующие мастер, для платы слейва, подключенной к компьютеру.

4.2.1 \distr\master\MBTest.exe
-запускаем, она просит ключ - жмем cancel
-дальше надо выставить:
Адрес (номер ком порта)
Устройство  (номер слейва к которому идет обращение,1 например)
Speed 115200
Начало 0 //номер регистра у слейва который требуется вычитать
Количество 10 //количество регистров
после этого щелкнуть по красной кнопке offline снизу слева.

4.2.2 \distr\master\modpoll.exe
Есть еще удобная консольная утилита, для того чтобы опрашивать  плату слейва из под Windows:
Например, чтобы прочитать у слейва с адресом 1, 10 регистров начиная с адреса 0x49 через COM3, набиваем:
modpoll -b 115200 -m rtu -a 1 -r 49 -c 10 COM3
